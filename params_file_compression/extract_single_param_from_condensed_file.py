#file intended to be used to extract a single params file from a condensed params list file (generated by condense_conformer_params_data.py; greatly reduce the memory overhead of the conformer library).
#The script takes in the file name (can include the path) of a condensed text file and the unique identifier number of the conformer (should be 1-15), and writes a params file that can be read by Rosetta
import os,sys

list_file_name = str(sys.argv[1])
conf_identifier = int(sys.argv[2])
ligand_name = str(sys.argv[3])

#read through the list file and collect the data of each line in a list as well as the condense keys

#letter code is the key, corresponding value is the entry
#i.e. _a is the key to "NAME"
condense_dict = {}

#the line data, go ahead and untranslate values taken from the condense dictionary, since we already have it
#only keep the line header and the values for the conformer (separated by commas)
#actually, we probably don't even have to store this. We can just print it in runtime
#lines_data = []

read_file = open(list_file_name, "r")

in_keys = False
in_params = False

write_file = open(ligand_name + ".params", "w")

for line in read_file.readlines():
	
	#strip the newline off the end of the line
	line_no_newline = line.strip("\n")

	#If the line is "KEYS" or "PARAMS", this denotes the header of each section
	if len(line_no_newline.split()) == 1 and line_no_newline == "KEYS":
		in_keys = True
		print(line_no_newline)
		continue
	if len(line_no_newline.split()) == 1 and line_no_newline == "PARAMS":
		in_params = True
		in_keys = False
		print(line_no_newline)
		continue
	#add a key
	if in_keys:
		#sanity check to ensure that the line is properly formatted; split length should be 2 and line should start with "_", otherwise something is wrong with the line
		if line_no_newline[0] != "_":
			print("This line is a bad key line because it is missing an underscore at the start of the line: " + line_no_newline)
			continue
		if len(line_no_newline.split()) != 2:
			print("This line is a bad key line because it idoes not split into 2 parts: " + line_no_newline)
			print("The line has " + str(len(line_no_newline.split())) + " parts")
			continue


		#if we pass the sanity check, read in the key pair
		key = str(line_no_newline.split()[0])
		entry = str(line_no_newline.split()[1])

		#sanity check to ensure the entry is not already in the dictionary (would be really bad if it is)
		if key in condense_dict:
			print(key + "is already somehow in the dictionary. That is not good!")
			continue

		condense_dict[key] = entry

	#get a data line
	if in_params:
		
		#line_data = []

		#sanity check to ensure that there is only 1 colon in the line (more will result in lost data)
		if len(line_no_newline.split(":")) > 2:
			print("Line has more colons than expected and data will not be read properly: " + line_no_newline)
			continue

		#split the line by each side of the colon (left side is the header, right side is the line data that is separated by commas per conformer)
		header_side = line_no_newline.split(":")[0]
		data_side = line_no_newline.split(":")[1]

		#look at the header side first and determine if this line is ocnserved across all conformers (denoted by an asterisk in the final position of the string)
		#also need to rewrite the header size to exclude an asterisk if it contains one
		conserved = False
		if header_side[len(header_side)-1] == "*":
			conserved = True

			#remove the asterisk at the end
			header_side = header_side[:-1]

		#translate the header side from the dictionary if applicable (it likely is)
		if header_side in condense_dict:
			header_side = condense_dict[header_side]

		#append the headerside to line_data
		#line_data.append(header_side)

		#look at the right hand side of the colon to get the conformer data
		#first, split by commas and pick the conformer index - 1 (or if conserved, pick index 0)
		split_data = data_side.split(",")

		#collect data for the conformer
		my_data = ""
		if conserved:
			my_data = split_data[0]
		else:
			my_data = split_data[conf_identifier - 1]

		#break up my_data so that we can translate it from the dictionary
		my_data_split = my_data.split()

		#look at each entry and translate if possible
		for i in range(len(my_data_split)):
			if str(my_data_split[i]) in condense_dict:
				my_data_split[i] = str(condense_dict[my_data_split[i]])

		#assemble my_data from the translated values, separating by a space
		my_data = ""
		for entry in my_data_split:
			my_data = my_data + " " + entry

		#assemble the whole line and add a newline
		assembled_line = header_side + my_data + "\n"
		write_file.write(assembled_line)

