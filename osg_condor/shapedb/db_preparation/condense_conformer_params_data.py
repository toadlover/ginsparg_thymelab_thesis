#script intended to take data of multiple conformer params files (generated by conformator) and create a condensed helper file that represents the coordinate data of the conformers

import os,sys,math

#base alphabetical dictionary with numerical key
alpha_dict = {0:'a',1:'b',2:'c',3:'d',4:'e',5:'f',6:'g',7:'h',8:'i',9:'j',10:'k',11:'l',12:'m',13:'n',14:'o',15:'p',16:'q',17:'r',18:'s',19:'t',20:'u',21:'v',22:'w',23:'x',24:'y',25:'z',26:'A',27:'B',28:'C',29:'D',30:'E',31:'F',32:'G',33:'H',34:'I',35:'J',36:'K',37:'L',38:'M',39:'N',40:'O',41:'P',42:'Q',43:'R',44:'S',45:'T',46:'U',47:'V',48:'W',49:'X',50:'Y',51:'Z'}

#look at all sdf files in the working location
location = os.getcwd()

#create a dictionary that holds data for each conformer param for each ligand
conformer_dict = {}

params_file_counter = 0

#look at all conformer sdf files
#conformer sdf files named as ligandname_idnum.sdf (look for the underscore)
#only look in working location (file root == location)
for r,d,f in os.walk(location):
	for file in f:
		#only look in location and underscore check in file name
		#not perfect check, but does filter out a lot
		if r == location and "_" in file and file.endswith(".params"):
			#read the file, pick out the coordinates of each atom
			#get ligand name and conformer number
			lig_name = file.split("_")[0]
			lig_num = int(file.split("_")[1].split(".")[0])

			params_file_counter = params_file_counter + 1
			print(file,params_file_counter)

			
			#values that hold constant across conformers (need to confirm ATOM, BOND, and CHI):
			#IO_STRING
			#TYPE
			#AA
			#ATOM
			#BOND_TYPE
			#CHI
			#PROTON_CHI


			#Values that are variable (NBR_ATOM may be constant)
			#NAME
			#NBR_ATOM
			#NBR_RADIUS
			#ICOOR_INTERNAL

			#read in the molecule and store data (as tuples in a list)
			"""
			name = ""
			io_string = []
			#these should likely be the seeded values
			conf_type = "LIGAND"
			aa = "UNK"

			atom_lines = []
			bond_type_lines = []
			"""

			#hold the molecule's line data in a list
			line_data = []

			"""
			#counter to count which line we are on
			#only concerned with line 4 to grab the atom count and then the atom lines (n lines after line 4, based on the 1st value of line 4)
			line_counter = 0

			atom_num = 0
			"""

			read_file = open(file, 'r')

			for line in read_file.readlines():
				#remove the newline at the end of the line
				stripped_line = line.split("\n")[0]

				#split the line up to make a sublist (removing spaces and likely memory overhead)
				stripped_line_split = stripped_line.split()



				line_data.append(stripped_line_split)

				#create/append conformer entry (key is conformer #, data is atom_coords) to conformer_dict
				#entry exists, append
			if lig_name in conformer_dict.keys():
				conformer_dict[lig_name].append([lig_num,line_data])
			#entry does not exist, create
			else:
				conformer_dict[lig_name] = []
				conformer_dict[lig_name].append([lig_num,line_data])
			

#now that all conformers are collected, create a compression file for each
for key in conformer_dict.keys():
	print(key)

	#number of conformers for a ligand
	num_confs = len(conformer_dict[key])

	highest_index = 0

	#within the ligand, perform a quick sanity check and make sure that the conformer count matches the highest number value (if we are missing one, that is likely not good)
	#conformer numbers index at 1, so highest value should equal the length
	for pair in conformer_dict[key]:
		#print(pair)
		if highest_index < pair[0]:
			highest_index = pair[0]

	print(highest_index,num_confs)

	if highest_index != num_confs:
		print("Ligand " + key + " has a highest index of " + str(highest_index) + ", but we only found " + str(num_confs) + " conformers")


	#write the compression file

	#extract the conformers data list
	conformer_data_list = conformer_dict[key]
	#this should be a 3D list
	#each conformer x each line x split data within the line


	#for line in conformer_data_list:
	#	print(line)
	#print()



	#sort the list by the id value
	#print("=================================================")
	conformer_data_list.sort()
	#for conf in conformer_data_list:
	#	print(conf[0])
	#	for line in conf[1]:
	#		print(line)
	#print("=================================================")
	#print()

	#separate out id from rest of data
	conformers_data = []
	for conf in conformer_data_list:
		conformers_data.append(conf[1])

	#structure should now be the 3D matrix again
	#conformer x line X separated entry
	#length of each conformers_data should be the same, each params file should be the same length of lines

	#run through each line and determine whether to use shorthand
	#build new list with shorthand and dictionary to hold the translation code
	#to avoid further redundancy, extract the first entry of the line that is the params line header (ATOM, BOND_TYPE, ICOOR_INTERNAL, etc), since that should always be the same across each line for conformers of a single molecules
	#hold the header at the front of the line
	shorthand_dict = {}
	shorthand_conformers_data = []

	#only make shordhand code for anything 4 characters or longer, unlikely that code will exceed 3 characters + underscore
	#to avoid encoding confusion with entries like atomic symbols, preceed code with single underscore
	#i.e. "_bT", "_gHe", "_q", etc.
	for conf in conformers_data:
		for line in conf:
			#run through each entry in the line and encode it if its length is 4 or longer
			for entry in line:
				#entries are the keys
				if len(str(entry)) >= 4 and entry not in shorthand_dict:
					#make a new code
					#code number based on current length of code_dict
					num_codes = len(shorthand_dict)

					#convert num_codes into a new code
					#determine number of times num_codes is dividible by 52
					#take log of num_codes and round up to nearest int
					#i.e. 0-51 rounds to 1, 52-2703 rounds to 2, 2704-140607 rounds to 3, etc.
					#each value translates to the length of the char
					#codes that are over 2 
					num_chars = 0
					if num_codes == 0:
						num_chars = 1
					else:  
						num_chars = int(math.log(num_codes,52)) + 1

					#extract each character
					#mod by 52 and then procedurally divide by 52 and round

					working_num_codes = num_codes
					build_string = ""
					for i in range(num_chars):
						#print(working_num_codes, working_num_codes % 52)
						mod = working_num_codes % 52
						mychar = alpha_dict[mod]
						build_string = mychar + build_string
						working_num_codes = int(working_num_codes / 52)
						#print(working_num_codes)
						#print(mychar)
					  
					#print(build_string)
					#append underscore to the front of the build_string
					build_string = "_" + build_string

					#make new dictionary entry for atom coords and the build_string with a counter
					shorthand_dict[entry] = [build_string,0]
					#print(shorthand_dict)
				#increment, only if already in the shorthand dict
				#using else (as opposed to elif) statement causes keyerrors for anything shorted than 4 characters
				elif entry in shorthand_dict:
					#already exists, increment the counter
					shorthand_dict[entry][1] = shorthand_dict[entry][1] + 1

	#shorthand dictionary built, now create the new conformer list 
	for conf in conformers_data:
		#new conformer to build line by line (append new lines to it)
		new_conf = []

		for line in conf:

			new_line = line

			#run through each entry in the line and encode it if present in the shorthand dictionary and the count is greater than 0 (counter starts at 0, so 1 means it shows up at least twice)
			#have as number to check indices
			for entry in range(len(new_line)):
				#if entry in shorthand dictionary and the count is greater than 0, replace with the shorthand
				if new_line[entry] in shorthand_dict:
					if shorthand_dict[new_line[entry]][1] > 0:
						new_line[entry] = shorthand_dict[new_line[entry]][0]

			#append the new line to new_conf
			new_conf.append(new_line)


			"""
			line_header = line[0]
			#will throw an error if fewer than 2 entries, but should always have at least 2 entries per line
			rest_of_line = line[1:]
			"""

		#append the completed conformer to shorthand conformers data
		shorthand_conformers_data.append(new_conf)

	#now that we have applied shorthand, write the file that shows the shorthand for conformers and has the key
	write_file = open(str(key) + "_shorthand_params.txt", "w")

	write_file.write("KEYS\n")

	#write the shorthand key at the top of the file
	#only write shorthand for keys that appeared 2+ times (count value 1 or higher)
	for key in shorthand_dict.keys():
		if shorthand_dict[key][1] > 0:
			write_file.write(str(shorthand_dict[key][0]) + " " + str(key) + "\n")

	write_file.write("PARAMS\n")

	#write appended lines of each conformer in order
	#separate conformer entries by comma
	#isolate line header at front, no need to repeat
	#iterate line by line
	for line_num in range(len(shorthand_conformers_data[0])):
		
		#determine if the line is the same across all conformers
		#if it is the same, we can further optimize on space by only printing the line of 1 conformer and denote that the line is the same across all conformers
		#if line of conformer 1 is the same as all other conformers, then all are the same (transitive property of equality)
		#to denote same content across a line, follow the line header with an asterisk "*" (before the colon)
		line_preserved = True

		for conformer_num in range(len(shorthand_conformers_data)):
			if shorthand_conformers_data[0][line_num] != shorthand_conformers_data[conformer_num][line_num]:
				line_preserved = False

		if line_preserved:
			#write the line header, end with asterisk, delineate by a colon
			write_file.write(str(shorthand_conformers_data[0][line_num][0]) + "*:")
		else:
			#write the line header, delineate by a colon
			write_file.write(str(shorthand_conformers_data[0][line_num][0]) + ":")


		for conformer_num in range(len(shorthand_conformers_data)):
			for entry_num in range(len(shorthand_conformers_data[conformer_num][line_num])):
				#continue if entry_num is 0
				if entry_num == 0:
					continue
				
				write_file.write(str(shorthand_conformers_data[conformer_num][line_num][entry_num]))

				#separate with a space if not at the end
				if(entry_num < (len(shorthand_conformers_data[conformer_num][line_num]) - 1)):
					write_file.write(" ")

			#end entry with a comma to separate
			write_file.write(",")

			#if line is preserved, only print once, break the loop
			if line_preserved:
				break

		#at end of line, writ enewline
		write_file.write("\n")

	#close write file, should be done with this ligands
	write_file.close()

