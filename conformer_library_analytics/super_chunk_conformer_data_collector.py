#the purpose of this script is to comb the data of a given super chunk (100 chunks, there are 531 super chunks) of the conformer library
#the program collects analytical data about the properties of the library, and collects the following:
#collects counts of number of conformers generated per ligand
#determines the molecular weight of the ligand (and bins ligands into bins of 10 amu)
#records a count of each atom encountered (can observe if there are rarer elements present in some molecules and how rare they are)

import os,sys

#going to try to use a heap data structure to better keep the best scores
import heapq

#dictionary that contains atom atomic weights for molecular mass calculation
#To save time, this dictionary was generated by ChatGPT3.5 with the prompt:
#Please write me a python3 dictionary that contains all periodic table element chemical symbols as keys and their atomic weights as values
#Please rewrite the dictionary so that there are 10 elements per line
periodic_table = {
    "H": 1.008, "He": 4.0026, "Li": 6.94, "Be": 9.0122, "B": 10.81,
    "C": 12.011, "N": 14.007, "O": 15.999, "F": 18.998, "Ne": 20.180,
    "Na": 22.990, "Mg": 24.305, "Al": 26.982, "Si": 28.085, "P": 30.974,
    "S": 32.06, "Cl": 35.45, "Ar": 39.948, "K": 39.098, "Ca": 40.078,
    "Sc": 44.956, "Ti": 47.867, "V": 50.942, "Cr": 51.996, "Mn": 54.938,
    "Fe": 55.845, "Co": 58.933, "Ni": 58.693, "Cu": 63.546, "Zn": 65.38,
    "Ga": 69.723, "Ge": 72.63, "As": 74.922, "Se": 78.971, "Br": 79.904,
    "Kr": 83.798, "Rb": 85.468, "Sr": 87.62, "Y": 88.906, "Zr": 91.224,
    "Nb": 92.906, "Mo": 95.95, "Tc": 98, "Ru": 101.07, "Rh": 102.91,
    "Pd": 106.42, "Ag": 107.87, "Cd": 112.41, "In": 114.82, "Sn": 118.71,
    "Sb": 121.76, "Te": 127.6, "I": 126.9, "Xe": 131.29, "Cs": 132.91,
    "Ba": 137.33, "La": 138.91, "Ce": 140.12, "Pr": 140.91, "Nd": 144.24,
    "Pm": 145, "Sm": 150.36, "Eu": 151.96, "Gd": 157.25, "Tb": 158.93,
    "Dy": 162.5, "Ho": 164.93, "Er": 167.26, "Tm": 168.93, "Yb": 173.05,
    "Lu": 174.97, "Hf": 178.49, "Ta": 180.95, "W": 183.84, "Re": 186.21,
    "Os": 190.23, "Ir": 192.22, "Pt": 195.08, "Au": 196.97, "Hg": 200.59,
    "Tl": 204.38, "Pb": 207.2, "Bi": 208.98, "Po": 209, "At": 210,
    "Rn": 222, "Fr": 223, "Ra": 226, "Ac": 227, "Th": 232.04, "Pa": 231.04,
    "U": 238.03, "Np": 237, "Pu": 244, "Am": 243, "Cm": 247, "Bk": 247,
    "Cf": 251, "Es": 252, "Fm": 257, "Md": 258, "No": 259, "Lr": 266,
    "Rf": 267, "Db": 270, "Sg": 271, "Bh": 270, "Hs": 269, "Mt": 278,
    "Ds": 281, "Rg": 282, "Cn": 285, "Nh": 286, "Fl": 289, "Mc": 288,
    "Lv": 293, "Ts": 294, "Og": 294,
}


#for the chunk finder, the value will be the minimum chunk, and we will look at 1000 chunks from there
chunk_finder = int(sys.argv[1])

#define the min and max chunks to look at
#i.e. 0 -> 0, 10 -> 1000, 530 -> 53,000
min_chunk = chunk_finder * 100

#define max chunk as the min + 99
#max_chunk = min_chunk + 99
#testing statement to only look at 10 chunks for now while testing
max_chunk = min_chunk + 99

#create dictionary to hold the distribution of conformers generated per ligand
#keys will be the conformer number and the value will be a counter for the number of times a ligand with a specific number of conformers is found
conformer_counts = {}

#create dictionaries to hold the binned molecular weights of ligands with and without counting hydrogens (especially if some ligands do have hydrogens and some don't)
#keys will be a rounding down of the molecular weight to the nearest 10 (i.e. 462.9->460)
molecular_weights_no_hydrogen = {}
molecular_weights_with_hydrogen = {}

#dictionary that counts the number of times an element is found
#key is the element chemical symbol and the value is a counter for the number of instances
elements_encountered_counter = {}

#i.e. 0 will have the range 0-99, 1 is 100-199, 10 is 1000-1099, 530 is 53,000-53,099 (this will be specifically cut to 53084 since that is the max)
#make strings for the min and max chunk
min_chunk_str = str(min_chunk)
while len(min_chunk_str) < 5:
	min_chunk_str = "0" + min_chunk_str

max_chunk_str = str(max_chunk)
while len(max_chunk_str) < 5:
	max_chunk_str = "0" + max_chunk_str

#make a directory to perform operations in to avoid collision with other concurrent instances of this program
os.system("mkdir " + str(chunk_finder))
os.chdir(str(chunk_finder))

#iterate through each chunk and its subchunks of ligands to pull the best scoring ligands for the given shape file prefix
for i in range(min_chunk,max_chunk + 1):
	
	#if the current chunk (i) is greater than 53084 (highest chunk), break the loop
	if i > 53084:
		print("We are exceeding the size of the library, breaking the loop.")
		break

	#construct a 5 digit string to access chunks (lead with zeroes)
	chunk_str = str(i)

	while len(chunk_str) < 5:
		chunk_str = "0" + chunk_str

	#iterate through each subchunk (0-9)
	for j in range(0,10):
		
		subchunk_str = str(j)
		print("On " + chunk_str + "," + subchunk_str)
		#pull the zipped file
		# s3cmd get s3://ariosg/ligand_library/00000/for_s3/condensed_params_and_db_0.tar.gz
		os.system("s3cmd get s3://ariosg/ligand_library/" + chunk_str + "/for_s3/condensed_params_and_db_" + subchunk_str + ".tar.gz")

		#unzip the file
		os.system("tar -xzvf condensed_params_and_db_" + subchunk_str + ".tar.gz")

		split_new_named_file = ""

		#open the split_new_named sdf file. If it is not present (it should be there, but maybe a subchunk broke in generation or something), kill the attempt to not break the script
		try:
			#read_file = open(chunk_str + "_" + subchunk_str + "_scored_confs_against_" + file_prefix + ".txt" , "r")
			split_new_named_file = open("condensed_params_and_db_" + subchunk_str + "/split_new_named_" + subchunk_str + ".sdf", "r")
		except:
			print("condensed_params_and_db_" + subchunk_str + "/split_new_named_" + subchunk_str + ".sdf is missing")
			continue

		#if we have what we need, continue analysis on this subchunk
		split_new_named_file = open("condensed_params_and_db_" + subchunk_str + "/split_new_named_" + subchunk_str + ".sdf", "r")

		#quick and easy bash eollection of conformer count
		#cat 00000_0_lig_name_list.txt | sed 's/_/ /g' | sort | awk '{print $1}' | uniq -c | awk '{print $1}' | sort | uniq -c | sort -k 2 -n | awk '{print $2 "," $1}'
		os.system("cat condensed_params_and_db_" + subchunk_str + "/" + chunk_str + "_" + subchunk_str + "_lig_name_list.txt | sed 's/_/ /g' | sort | awk '{print $1}' | uniq -c | awk '{print $1}' | sort | uniq -c | sort -k 2 -n | awk '{print $2 \",\" $1}' > subchunk_conf_count.csv")

		#read the subchunk conf count file and get the counts of conformers for the subchunk
		small_file = open("subchunk_conf_count.csv","r")
		for line in small_file.readlines():
			#get the conf num and count and then add to the dictionary (making a new entry if one does not already exist)
			conf_num = line.split(",")[0]
			count = int(line.split(",")[1].strip())

			#determine if we have the conf num as a key already in the conf dictionary (we should after the first few files we look at)
			if conf_num in conformer_counts.keys():
				conformer_counts[conf_num] = conformer_counts[conf_num] + count
			else:
				conformer_counts[conf_num] = count

		small_file.close()

		#read the split_new_named file and obtain the molecular masses of each molecule as well as the number 

		#variable to hold the working molecular mass of the molecule being looked at
		curr_mol_mass = 0
		curr_mol_mass_no_h = 0

		for line in split_new_named_file.readlines():
			#if the line has atom data
			if len(line.split()) >= 4:
				#check if the value is in the atom dictionary (I know that we could hit bond data, but this check ensures we don't mess with bond data because there are no numbers in the dictionary)
				cur_atom = line.split()[3]

				#we have an atom
				if cur_atom in periodic_table.keys():
					#add the atom's mass to the current molecular mass
					curr_mol_mass = curr_mol_mass + periodic_table[cur_atom]
					if cur_atom != "H":
						curr_mol_mass_no_h = curr_mol_mass_no_h + periodic_table[cur_atom]

					#count the atom in the atom occurence dictionary
					if cur_atom in elements_encountered_counter.keys():
						elements_encountered_counter[cur_atom] = elements_encountered_counter[cur_atom] + 1
					else:
						elements_encountered_counter[cur_atom] = 1
			#if at the end of the molecule, collect the molecular mass, conform it to the 10amu bin, and then add it to the dictionary
			if "$$$$" in line:
				curr_mol_mass = int(curr_mol_mass/10) * 10
				curr_mol_mass_no_h = int(curr_mol_mass_no_h/10) * 10

				print("molar_masses",curr_mol_mass,curr_mol_mass_no_h)

				#add the masses to the dictionaries
				if curr_mol_mass in molecular_weights_with_hydrogen.keys():
					molecular_weights_with_hydrogen[curr_mol_mass] = molecular_weights_with_hydrogen[curr_mol_mass] + 1
				else:
					molecular_weights_with_hydrogen[curr_mol_mass] = 1

				if curr_mol_mass_no_h in molecular_weights_no_hydrogen.keys():
					molecular_weights_no_hydrogen[curr_mol_mass_no_h] = molecular_weights_no_hydrogen[curr_mol_mass_no_h] + 1
				else:
					molecular_weights_no_hydrogen[curr_mol_mass_no_h] = 1


				#reset masses
				curr_mol_mass = 0
				curr_mol_mass_no_h = 0				


		#delete the subchunk from local space for cleanliness
		os.system("rm -drf condensed* *csv")

		#as a tracker, print the state of all dictionaries
		print("confs",conformer_counts)
		print("elements",elements_encountered_counter)
		print("mw no h",molecular_weights_no_hydrogen)
		print("mw with h",molecular_weights_with_hydrogen)

#at end, write all dictionaries to files
#open files to write the analytics to
conf_count_file = open("conformer_counter_" + str(chunk_finder) + ".csv", "w")
mw_no_h_file = open("molecular_weight_no_h_" + str(chunk_finder) + ".csv", "w")
mw_h_file = open("molecular_weight_h_" + str(chunk_finder) + ".csv", "w")
elements_encountered_file = open("elements_encountered_" + str(chunk_finder) + ".csv", "w")

#conformer counts
for conf in conformer_counts.keys():
	conf_count_file.write(str(conf) + "," + str(conformer_counts[conf]) + "\n")

#molecular weights
for mole in molecular_weights_no_hydrogen.keys():
	mw_no_h_file.write(str(mole) + "," + str(molecular_weights_no_hydrogen[mole]) + "\n")
for mole in molecular_weights_with_hydrogen.keys():
	mw_h_file.write(str(mole) + "," + str(molecular_weights_with_hydrogen[mole]) + "\n")

#element counters
for ele in elements_encountered_counter.keys():
	elements_encountered_file.write(str(ele) + "," + str(elements_encountered_counter[ele]) + "\n")
