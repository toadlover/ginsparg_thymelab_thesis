#the purpose of this script is to take a target placed ligand in pdb format and a folder of placed ligands in pdb format, and determine which placements per ligand are the most similar
#the comparison is made by converting the target and comparison ligand atom placements to 1 cubic angstrom voxels to simplify their placements, and then compare the placement of voxels between the target and placement
#voxels are determined by rounding down atom coordinates to the nearest integer, with the 1 cubic angstrom being bound by the rounded down coordinates (n) to n+1
#to account for atom weight, an analysis will also be performed that attributes the atomic weight of all atoms in the voxel (likely no more than 1 atom per voxel), and weight will be used in a secondary analysis
#placement difference is quantified by the number of voxels that do not align between the target and compare placement with a value of 0 being perfect overlap
#in the analysis that accounts for weight, the sum of  absolute differences in weight per voxel will be taken and a value of 0 indicates perfect alignment
#the target system and compare systems must be aligned before this script, or else there will be complete mismatch
#this script can return either the single top placement (default) or the top x placements per ligand
#ligand is determined by the HETNAM line of the placements pdb

#run as: python ligand_placement_voxel_comparison_of_placements_directory_against_target.py target_protein.pdb /path/to/placements_directory/ top_x_integer(optional)

#imports
import os,sys

#read in args
target_placement = sys.argv[1]

placements_directory = sys.argv[2]

#if the length of args is 4, grab the top x argument
top_x_to_keep = 1

if len(sys.argv) == 4:
	top_x_to_keep = int(sys.argv[3])

#create lists and dictionaries to hold ligand data

#create list to hold that target ligand data
#this list will hold voxel data, each entry in the list will be a 3 entry tuple of rounded values of coorinates of each atom from the target ligand
#duplicates will not be included/there will be a duplicate check with duplicates not included
target_ligand_voxels_space = []

#similar to the target ligand voxels for space, but will contain a 4  entry tuple. The first 3 tuple values will be rounded xyz, and the last value will be the sum of weights of any atoms in the voxel (likely 1 atom per occupied voxel)
target_ligand_voxels_weight = []

#create a dictionary to organize the placements in the placement folder by ligand
#ligand name will be used as a key, which will be extracted from each file's HETNAM line (the ligand name being taken as everything before the first underscore as well)
#for each ligand key, there will be a list that lists each file processed, along with the space and weight difference scores
placed_ligands_data_dict = {}

#dictionary generated by chatgpt that contains relevant elements found in organic molecules for voxel weight analysis
#all symbols are upper, and collected symbols will be cast to upper to ensure matching
atomic_weights = {
    'H': 1.008,   # Hydrogen  
    'C': 12.011,  # Carbon  
    'O': 15.999,  # Oxygen  
    'N': 14.007,  # Nitrogen  
    'P': 30.974,  # Phosphorus  
    'S': 32.06,   # Sulfur  
    'F': 18.998,  # Fluorine  
    'CL': 35.45,  # Chlorine  
    'BR': 79.904, # Bromine  
    'I': 126.90   # Iodine  
}

#read through the target placement and derive the voxel lists for it
target_placement_file = open(target_placement, "r")

for line in target_placement.readlines():
	#if the line starts with HETATM, we can collect the data
	if line.startswith("HETATM"):
		#collect the coordinates and element
		x = int(float(line[30:38].strip()))
		y = int(float(line[38:46].strip()))
		z = int(float(line[46:54].strip()))
		element = line[76:78].strip().upper()

		#check if the voxel exists in the target space list, and add if not
		if [x,y,z] not in target_ligand_voxels_space:
			target_ligand_voxels_space.append([x,y,z])

		#add to weight list

		#bool to determine whether the voxel coordinates are in the weight vector (harder to line up because the tuple also contains weight)
		#if the value is false after running through all previously recorded voxels, we add a new voxel with the weight of the corresponding element
		weight_voxel_exists = False

		for i in range(len(target_ligand_voxels_weight)):
			#if we get a match from having the voxel exist already, add the element weight to the existing element weight value
			if target_ligand_voxels_weight[i][0] == x and target_ligand_voxels_weight[i][1] == y and target_ligand_voxels_weight[i][2] == z:
				target_ligand_voxels_weight[i][3] = target_ligand_voxels_weight[i][3] + atomic_weights[element]
				weight_voxel_exists = True

		#if we did not find an existing voxel, add it to the list
		if weight_voxel_exists == False:
			target_ligand_voxels_weight.append([x,y,z,atomic_weights[element]])

#test print of lists
for line in target_ligand_voxels_space:
	print(line)

for line in target_ligand_voxels_weight:
	print(line)

