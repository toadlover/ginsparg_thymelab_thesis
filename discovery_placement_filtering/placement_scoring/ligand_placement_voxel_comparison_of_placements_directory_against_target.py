#the purpose of this script is to take a target placed ligand in pdb format and a folder of placed ligands in pdb format, and determine which placements per ligand are the most similar
#the comparison is made by converting the target and comparison ligand atom placements to 1 cubic angstrom voxels to simplify their placements, and then compare the placement of voxels between the target and placement
#voxels are determined by rounding down atom coordinates to the nearest integer, with the 1 cubic angstrom being bound by the rounded down coordinates (n) to n+1
#to account for atom weight, an analysis will also be performed that attributes the atomic weight of all atoms in the voxel (likely no more than 1 atom per voxel), and weight will be used in a secondary analysis
#placement difference is quantified by the number of voxels that do not align between the target and compare placement with a value of 0 being perfect overlap
#in the analysis that accounts for weight, the sum of  absolute differences in weight per voxel will be taken and a value of 0 indicates perfect alignment
#the target system and compare systems must be aligned before this script, or else there will be complete mismatch
#this script can return either the single top placement (default) or the top x placements per ligand
#ligand is determined by the HETNAM line of the placements pdb

#run as: python ligand_placement_voxel_comparison_of_placements_directory_against_target.py target_protein.pdb /path/to/placements_directory/  top_x_integer mismatch_threshold

#imports
import os,sys

#read in args
target_placement = sys.argv[1]

placements_directory = sys.argv[2]

if placements_directory.endswith("/") == False:
	placements_directory = placements_directory + "/"

#if the length of args is 4, grab the top x argument
top_x_to_keep = int(sys.argv[3])

#mismatch threshold of values (column 2) for placements to consider keeping at end
#value based on the the space match value
mismatch_space_threshold = int(sys.argv[4])

#create lists and dictionaries to hold ligand data

#create list to hold that target ligand data
#this list will hold voxel data, each entry in the list will be a 3 entry tuple of rounded values of coorinates of each atom from the target ligand
#duplicates will not be included/there will be a duplicate check with duplicates not included
target_ligand_voxels_space = []

#similar to the target ligand voxels for space, but will contain a 4  entry tuple. The first 3 tuple values will be rounded xyz, and the last value will be the sum of weights of any atoms in the voxel (likely 1 atom per occupied voxel)
target_ligand_voxels_weight = []

#create a dictionary to organize the placements in the placement folder by ligand
#ligand name will be used as a key, which will be extracted from each file's HETNAM line (the ligand name being taken as everything before the first underscore as well)
#for each ligand key, there will be a list that lists each file processed, along with the space and weight difference scores
placed_ligands_data_dict = {}

#dictionary generated by chatgpt that contains relevant elements found in organic molecules for voxel weight analysis
#all symbols are upper, and collected symbols will be cast to upper to ensure matching
atomic_weights = {
    'H': 1.008,   # Hydrogen  
    'C': 12.011,  # Carbon  
    'O': 15.999,  # Oxygen  
    'N': 14.007,  # Nitrogen  
    'P': 30.974,  # Phosphorus  
    'S': 32.06,   # Sulfur  
    'F': 18.998,  # Fluorine  
    'CL': 35.45,  # Chlorine  
    'BR': 79.904, # Bromine  
    'I': 126.90   # Iodine  
}

#read through the target placement and derive the voxel lists for it
target_placement_file = open(target_placement, "r")

for line in target_placement_file.readlines():
	#if the line starts with HETATM, we can collect the data
	if line.startswith("HETATM"):
		#collect the coordinates and element
		x = round(float(line[30:38].strip()))
		y = round(float(line[38:46].strip()))
		z = round(float(line[46:54].strip()))
		element = line[76:78].strip().upper()

		#ignore hydrogens
		if element == "H":
			continue

		#check if the voxel exists in the target space list, and add if not
		if [x,y,z] not in target_ligand_voxels_space:
			target_ligand_voxels_space.append([x,y,z])

		#add to weight list

		#bool to determine whether the voxel coordinates are in the weight vector (harder to line up because the tuple also contains weight)
		#if the value is false after running through all previously recorded voxels, we add a new voxel with the weight of the corresponding element
		weight_voxel_exists = False

		for i in range(len(target_ligand_voxels_weight)):
			#if we get a match from having the voxel exist already, add the element weight to the existing element weight value
			if target_ligand_voxels_weight[i][0] == x and target_ligand_voxels_weight[i][1] == y and target_ligand_voxels_weight[i][2] == z:
				target_ligand_voxels_weight[i][3] = target_ligand_voxels_weight[i][3] + atomic_weights[element]
				weight_voxel_exists = True

		#if we did not find an existing voxel, add it to the list
		if weight_voxel_exists == False:
			target_ligand_voxels_weight.append([x,y,z,atomic_weights[element]])

#test print of lists
#for line in target_ligand_voxels_space:
#	print(line)

#for line in target_ligand_voxels_weight:
#	print(line)

#now, run through each file in the placements directory and determine the similarity of each file
for r,d,f in os.walk(placements_directory):
	for file in f:
		#print(r + "/" + file)
		#only look at files at the top level and only pdbs
		if file.endswith(".pdb") and r == placements_directory:
			print(file)

			#read the file and get the data
			#hold the lignd name too
			lig_name = ""

			#open the file
			placement_file = open(r + "/" + file, "r")

			#create lists for the placement
			compare_ligand_voxels_space = []

			compare_ligand_voxels_weight = []

			for line in placement_file.readlines():
				if line.startswith("HETNAM"):
					#extract the ligand name
					lig_name = line[12:].strip().split("_")[0]

				#if the line starts with HETATM, we can collect the data
				if line.startswith("HETATM"):
					#collect the coordinates and element
					#x = int(float(line[30:38].strip()))
					#y = int(float(line[38:46].strip()))
					#z = int(float(line[46:54].strip()))

					#adjust rounding logic so that it goes to the closest int, not rounding down
					x = round(float(line[30:38].strip()))
					y = round(float(line[38:46].strip()))
					z = round(float(line[46:54].strip()))

					element = line[76:78].strip().upper()

					#ignore hydrogens
					if element == "H":
						continue

					#check if the voxel exists in the target space list, and add if not
					if [x,y,z] not in compare_ligand_voxels_space:
						compare_ligand_voxels_space.append([x,y,z])

					#add to weight list

					#bool to determine whether the voxel coordinates are in the weight vector (harder to line up because the tuple also contains weight)
					#if the value is false after running through all previously recorded voxels, we add a new voxel with the weight of the corresponding element
					weight_voxel_exists = False

					for i in range(len(compare_ligand_voxels_weight)):
						#if we get a match from having the voxel exist already, add the element weight to the existing element weight value
						if compare_ligand_voxels_weight[i][0] == x and compare_ligand_voxels_weight[i][1] == y and compare_ligand_voxels_weight[i][2] == z:
							compare_ligand_voxels_weight[i][3] = compare_ligand_voxels_weight[i][3] + atomic_weights[element]
							weight_voxel_exists = True

					#if we did not find an existing voxel, add it to the list
					if weight_voxel_exists == False:
						compare_ligand_voxels_weight.append([x,y,z,atomic_weights[element]])

			#we now have the voxel data of the element
			#compare the voxels against the target

			#initialize scores to start at 0
			space_difference = 0
			weight_difference = 0

			#list to hold voxels with space differences
			space_diff_list_target = []
			space_diff_list_compare = []

			#space compare
			#need to compare target vs compare and then compare vs target
			#difference = sum of voxels that do not overlap from either
			"""
			for voxel in target_ligand_voxels_space:
				if voxel not in compare_ligand_voxels_space:
					space_difference = space_difference + 1
					space_diff_list_target.append(voxel)

			for voxel in compare_ligand_voxels_space:
				if voxel not in target_ligand_voxels_space:
					space_difference = space_difference + 1
					space_diff_list_compare.append(voxel)
			"""

			#adjusting logic to be more tolerant and counting overlap if complete overlap or 1 angstrom away (in any direction including corners, so adjacent 26 voxels)
			for voxel in target_ligand_voxels_space:
				
				voxel_overlaps = False

				for voxel2 in compare_ligand_voxels_space:
					if (voxel[0] == voxel2[0] or voxel[0] == voxel2[0] - 1 or voxel[0] == voxel2[0] + 1) and (voxel[1] == voxel2[1] or voxel[1] == voxel2[1] - 1 or voxel[1] == voxel2[1] + 1) and (voxel[2] == voxel2[2] or voxel[2] == voxel2[2] - 1 or voxel[2] == voxel2[2] + 1):
						voxel_overlaps = True

				if voxel_overlaps == False:
					space_difference = space_difference + 1
					space_diff_list_target.append(voxel)

			for voxel in compare_ligand_voxels_space:
				
				voxel_overlaps = False

				for voxel2 in target_ligand_voxels_space:
					if (voxel[0] == voxel2[0] or voxel[0] == voxel2[0] - 1 or voxel[0] == voxel2[0] + 1) and (voxel[1] == voxel2[1] or voxel[1] == voxel2[1] - 1 or voxel[1] == voxel2[1] + 1) and (voxel[2] == voxel2[2] or voxel[2] == voxel2[2] - 1 or voxel[2] == voxel2[2] + 1):
						voxel_overlaps = True

				if voxel_overlaps == False:
					space_difference = space_difference + 1
					space_diff_list_compare.append(voxel)	

			#print(space_diff_list_target)
			#print(space_diff_list_compare)

			#weighted compare
			#similar to space method, but do need to take the absolute difference in weights; need to compare t vs c and then c vs t
			#also need to ensure we do not double dip in weight differences for voxels that do overlap, so we need to hold overlapped voxels in a list to ensure they are not counted twice
			
			#overlapped voxels list
			overlapped_voxels = []

			for voxel in target_ligand_voxels_weight:
				#bool to hold if we overlap the voxel or not
				overlaps = False

				#hold the overlap voxel weight (or the value will be 0 if no overlap)
				overlap_voxel_weight = 0

				#check if the voxel exists in opposite set
				#need to check by iterating over the other set since there may not be an exact match if weight is different
				for voxel2 in compare_ligand_voxels_weight:
					if (voxel[0] == voxel2[0] or voxel[0] == voxel2[0] - 1 or voxel[0] == voxel2[0] + 1) and (voxel[1] == voxel2[1] or voxel[1] == voxel2[1] - 1 or voxel[1] == voxel2[1] + 1) and (voxel[2] == voxel2[2] or voxel[2] == voxel2[2] - 1 or voxel[2] == voxel2[2] + 1):
						overlaps = True
						overlap_voxel_weight = voxel2[3]

				weight_difference = weight_difference + abs(voxel[3] - overlap_voxel_weight)

				#if we overlap, add the voxel to the list of overlapped voxels
				if overlaps:
					overlapped_voxels.append(voxel)

			#now repeat reverse compare
			for voxel in compare_ligand_voxels_weight:

				is_overlapped = False

				#check if the voxel is in the overlap set
				for overlap_voxel in overlapped_voxels:
					if (voxel[0] == overlap_voxel[0] or voxel[0] == overlap_voxel[0] - 1 or voxel[0] == overlap_voxel[0] + 1) and (voxel[1] == overlap_voxel[1] or voxel[1] == overlap_voxel[1] - 1 or voxel[1] == overlap_voxel[1] + 1) and (voxel[2] == overlap_voxel[2] or voxel[2] == overlap_voxel[2] - 1 or voxel[2] == overlap_voxel[2] + 1):
						is_overlapped = True

				#continue if overlapped
				if is_overlapped:
					continue

				#hold the overlap voxel weight (or the value will be 0 if no overlap)
				overlap_voxel_weight = 0

				#check if the voxel exists in opposite set
				#need to check by iterating over the other set since there may not be an exact match if weight is different
				for voxel2 in target_ligand_voxels_weight:
					if voxel[0] == voxel2[0] and voxel[1] == voxel2[1] and voxel[2] == voxel2[2]:
						overlap_voxel_weight = voxel2[3]

				weight_difference = weight_difference + abs(voxel[3] - overlap_voxel_weight)
		
				
			#we now have our differences, assign them to the dictionary
			#behavior for if the dictionary already has a key for the ligand
			if lig_name in placed_ligands_data_dict.keys():
				#append
				placed_ligands_data_dict[lig_name].append([r + "/" + file, space_difference, weight_difference])
			else:
				#declare new list
				placed_ligands_data_dict[lig_name] = [[r + "/" + file, space_difference, weight_difference]]

#sort all ligand lists by space overlap
for lig in placed_ligands_data_dict.keys():
	for placement in placed_ligands_data_dict[lig]:
		temp = sorted(placed_ligands_data_dict[lig], key=lambda x: (x[1],x[2]))
		placed_ligands_data_dict[lig] = temp

#create a directory to put the best placements within the top x threshold
os.system("rm -drf closest_" + str(top_x_to_keep) + "_placements")
os.system("mkdir closest_" + str(top_x_to_keep) + "_placements")

#print a csv file for each ligand containing the similarity data
for lig in placed_ligands_data_dict.keys():
	
	write_file = open(lig + "_placement_similarity_scoring.csv", "w")

	write_file.write("file,space_score,weight_score\n")

	#counter to track the number of placements addedto the closest folder
	placements_copied = 0

	#print(lig)
	for placement in placed_ligands_data_dict[lig]:
		#print(placement)
		write_file.write(str(placement[0]) + "," + str(placement[1]) + "," + str(placement[2]) + "\n")

		if placements_copied < top_x_to_keep:
			placements_copied = placements_copied + 1

			if placement[1] <= mismatch_space_threshold:
				os.system("cp " + placement[0] + " closest_" + top_x_to_keep + "_placements")

